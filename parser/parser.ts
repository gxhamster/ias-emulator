// Parser takes a list of tokens generated by the 

import { Instruction } from "../emulator/emulator";
import { TokenType, type Token } from "./lexer";
import { LOAD_FROM_MQ } from "./tokenMappings";

// Scanner class and maps them to actual instructions
class Parser {
    private totalTokens: Array<Array<Token>> = new Array()
    private instructions: Array<Instruction> = new Array();

    constructor(tokens: Token[]) {
        if (!tokens.length)
            throw new Error(`Cannot parse if tokens are empty! -> ${tokens}`)
       
        // Address translation
        tokens = this.parseHexAddressToBase10(tokens);

        // Instructions in each line grouped together
        for (const token of tokens) {
            if (this.totalTokens[token.line]) {
                this.totalTokens[token.line] = []
            }
            this.totalTokens[token.line].push(token);
        }

    }

    // As a preliminary step convert all hex to dec. This is for 
    // consistency and so that we dont have to match for two versions
    // in the parsing process.
    private parseHexAddressToBase10(tokens: Token[]) {
        for (let i = 0; i < tokens.length; i++) {
            if (tokens[i].tokenType == TokenType.MEMORY_ADDRESS_HEX) {
                const base10 = parseInt(tokens[i].lexeme, 16);
                if (!Number.isNaN(base10)) {
                    tokens[i].lexeme = base10.toString()
                } else {
                    throw new Error(`Error occured during address translation to base10, Token: ${tokens[i]}`)
                }
            }
        }

        return tokens;
    }

    parse() {
        // Pattern match for each instruction using the token type
        const ins = [TokenType.LOAD, TokenType.REGISTER_MQ]
        let currentLineTokens: Token[] = Array();
        for (let i = 0; i < this.totalTokens.length; i++) {
            currentLineTokens = this.totalTokens[i];
            if (this.matchTokens(currentLineTokens, LOAD_FROM_MQ)) {
                // Generate instructions
                this.addInstruction(new Instruction(10))
            }
        }
    }

    private addInstruction(instruction: Instruction) {
        this.instructions.push(instruction);
    }

    // Check if any two arrays of tokens are the same
    private matchTokens(line: Token[], reference: TokenType[]) {
        if (line.length != reference.length)
            return false
        for (let i = 0; i < reference.length; i++) {
            if (line[i].tokenType != reference[i])
                return false 
        }

        return true
    }
}