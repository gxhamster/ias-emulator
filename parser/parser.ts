// Parser takes a list of tokens generated by the

import { Instruction } from "../emulator/emulator";
import { Opcode } from "../emulator/opcodes";
import { TokenType, type Token } from "./lexer";
import {
  ADD,
  ADD_ABS,
  DIV,
  HLT,
  JUMP_COND_LEFT,
  JUMP_COND_RIGHT,
  JUMP_LEFT,
  JUMP_RIGHT,
  LOAD_FROM_MEMORY,
  LOAD_FROM_MEMORY_ABS,
  LOAD_FROM_MEMORY_ABS_NEG_OFF,
  LOAD_FROM_MEMORY_NEG_OFF,
  LOAD_FROM_MQ,
  LOAD_TO_MQ,
  LSH,
  MUL,
  RSH,
  STOR_REPLACE_LEFT,
  STOR_REPLACE_RIGHT,
  STOR_TO_MEMORY,
  STORI,
  SUB,
  SUB_ABS,
} from "./tokenMappings";

// Scanner class and maps them to actual instructions
export class Parser {
  private _totalTokens: Array<Array<Token>> = new Array();
  public instructions: Array<Instruction> = new Array();

  constructor(tokens: Token[]) {
    this.readTokens(tokens);
  }

  public readTokens(tokens: Token[]) {
    if (tokens.length <= 0)
      throw new Error(`Cannot parse if tokens are empty! -> ${tokens}`);

    // Reset the parser state when reading new tokens
    this._totalTokens = new Array();
    this.instructions = new Array();

    // Address translation
    tokens = this.parseHexAddressToBase10(tokens);

    // Instructions in each line grouped together
    for (const token of tokens) {
      if (!this._totalTokens[token.line]) {
        this._totalTokens[token.line] = [];
      }
      this._totalTokens[token.line].push(token);
    }
  }

  // As a preliminary step convert all hex to dec. This is for
  // consistency and so that we dont have to match for two versions
  // in the parsing process.
  private parseHexAddressToBase10(tokens: Token[]) {
    for (let i = 0; i < tokens.length; i++) {
      if (tokens[i].tokenType == TokenType.MEMORY_ADDRESS_HEX) {
        const base10 = parseInt(tokens[i].lexeme, 16);
        if (!Number.isNaN(base10)) {
          tokens[i].lexeme = base10.toString();
          tokens[i].tokenType = TokenType.MEMORY_ADDRESS_DEC;
        } else {
          throw new Error(
            `Error occured during address translation to base10, Token: ${tokens[i]}`
          );
        }
      }
    }

    return tokens;
  }

  parse() {
    // Pattern match for each instruction using the token type
    let curTokens: Token[] = Array();
    for (let i = 0; i < this._totalTokens.length; i++) {
      curTokens = this._totalTokens[i];

      // Generate instructions
      if (this.matchTokens(curTokens, LOAD_FROM_MEMORY)) {
        const addr = this.getAddressFromInstructionTokens(curTokens);
        this.addInstruction(new Instruction(Opcode.LOAD, addr));
      } else if (this.matchTokens(curTokens, LOAD_FROM_MEMORY_NEG_OFF)) {
        const addr = this.getAddressFromInstructionTokens(curTokens);
        this.addInstruction(new Instruction(Opcode.LOAD_NEG, addr));
      } else if (this.matchTokens(curTokens, LOAD_FROM_MEMORY_ABS)) {
        const addr = this.getAddressFromInstructionTokens(curTokens);
        this.addInstruction(new Instruction(Opcode.LOAD_ABS, addr));
      } else if (this.matchTokens(curTokens, LOAD_FROM_MEMORY_ABS_NEG_OFF)) {
        const addr = this.getAddressFromInstructionTokens(curTokens);
        this.addInstruction(new Instruction(Opcode.LOAD_ABS_NEG, addr));
      } else if (this.matchTokens(curTokens, ADD)) {
        const addr = this.getAddressFromInstructionTokens(curTokens);
        this.addInstruction(new Instruction(Opcode.ADD, addr));
      } else if (this.matchTokens(curTokens, SUB)) {
        const addr = this.getAddressFromInstructionTokens(curTokens);
        this.addInstruction(new Instruction(Opcode.SUB, addr));
      } else if (this.matchTokens(curTokens, ADD_ABS)) {
        const addr = this.getAddressFromInstructionTokens(curTokens);
        this.addInstruction(new Instruction(Opcode.ADD_ABS, addr));
      } else if (this.matchTokens(curTokens, SUB_ABS)) {
        const addr = this.getAddressFromInstructionTokens(curTokens);
        this.addInstruction(new Instruction(Opcode.SUB_ABS, addr));
      } else if (this.matchTokens(curTokens, LOAD_TO_MQ)) {
        const addr = this.getAddressFromInstructionTokens(curTokens);
        this.addInstruction(new Instruction(Opcode.LOAD_TO_MQ, addr));
      } else if (this.matchTokens(curTokens, LOAD_FROM_MQ)) {
        this.addInstruction(new Instruction(Opcode.LOAD_FROM_MQ));
      } else if (this.matchTokens(curTokens, MUL)) {
        const addr = this.getAddressFromInstructionTokens(curTokens);
        this.addInstruction(new Instruction(Opcode.MUL, addr));
      } else if (this.matchTokens(curTokens, DIV)) {
        const addr = this.getAddressFromInstructionTokens(curTokens);
        this.addInstruction(new Instruction(Opcode.DIV, addr));
      } else if (this.matchTokens(curTokens, JUMP_LEFT)) {
        if (this.isJumpAddressRight(curTokens)) {
          const addr = this.getAddressFromInstructionTokens(curTokens);
          this.addInstruction(new Instruction(Opcode.JUMP_RIGHT, addr));
        } else {
          const addr = this.getAddressFromInstructionTokens(curTokens);
          this.addInstruction(new Instruction(Opcode.JUMP_LEFT, addr));
        }
      } else if (this.matchTokens(curTokens, JUMP_COND_LEFT)) {
        if (this.isJumpAddressRight(curTokens)) {
          const addr = this.getAddressFromInstructionTokens(curTokens);
          this.addInstruction(new Instruction(Opcode.COND_JUMP_RIGHT, addr));
        } else {
          const addr = this.getAddressFromInstructionTokens(curTokens);
          this.addInstruction(new Instruction(Opcode.COND_JUMP_LEFT, addr));
        }
      } else if (this.matchTokens(curTokens, STOR_REPLACE_LEFT)) {
        // Handle the replace address side
        if (this.isAddressHintRight(curTokens)) {
          // Run STOR M(X,28:39) -> RIGHT
          const addr = this.getAddressFromInstructionTokens(curTokens);
          this.addInstruction(new Instruction(Opcode.RIGHT_ADDR_MODIFY, addr));
        } else {
          // Otherwise STOR M(X,8:19) -> LEFT
          const addr = this.getAddressFromInstructionTokens(curTokens);
          this.addInstruction(
            new Instruction(0, 0, Opcode.LEFT_ADDR_MODIFY, addr)
          );
        }
      } else if (this.matchTokens(curTokens, LSH)) {
        this.addInstruction(new Instruction(Opcode.LSH));
      } else if (this.matchTokens(curTokens, RSH)) {
        this.addInstruction(new Instruction(Opcode.RSH));
      } else if (this.matchTokens(curTokens, STOR_TO_MEMORY)) {
        const addr = this.getAddressFromInstructionTokens(curTokens);
        this.addInstruction(new Instruction(Opcode.STOR, addr));
      } else if (this.matchTokens(curTokens, HLT)) {
        this.addInstruction(new Instruction(Opcode.HLT));
      } else if (this.matchTokens(curTokens, STORI)) {
        const addr = this.getAddressFromInstructionTokens(curTokens);
        const immValue = this.getImmediateValue(curTokens);
        if (immValue !== null) {
          this.addInstruction(
            new Instruction(0x0, immValue, Opcode.STORI, addr)
          );
        } else {
          throw new Error(
            `Store immediate instruction parse failed. Invalid imm value. Value: ${immValue}`
          );
        }
      } else {
        throw new Error(
          `Unknown instruction pattern used, Instructions pattern: ${this.displayInstructionTokens(
            curTokens
          )}`
        );
      }
    }
  }

  // Tries to get the address parameter required by the
  // instruction. Returns the first address token it finds
  // TODO: Could be bad
  private getAddressFromInstructionTokens(tokens: Token[]) {
    let address: number;
    for (const token of tokens) {
      if (token.tokenType === TokenType.MEMORY_ADDRESS_DEC) {
        // All addreses should be converted to base 10 by now
        address = parseInt(token.lexeme);
        if (Number.isNaN(address)) {
          throw new Error("Could not get address from tokens list!");
        }
        return address;
      }
    }
  }

  private displayInstructionTokens(tokens: Token[]) {
    // Join everything after the opcode
    const temp = tokens.filter((tok, idx) => idx > 0);
    const lexemes = temp.map((tok) => tok.lexeme);
    return `${tokens[0].lexeme} ${lexemes.join("")}`;
  }

  private addInstruction(instruction: Instruction) {
    this.instructions.push(instruction);
  }

  // Check if any two arrays of tokens are the same
  private matchTokens(line: Token[], reference: TokenType[]) {
    if (line.length != reference.length) return false;
    for (let i = 0; i < reference.length; i++) {
      if (line[i].tokenType != reference[i]) return false;
    }

    return true;
  }

  // STOR M(X,8:19) in a instruction like that get the 8:19 part.
  // 8:19 is left address portion and 28:39 is right address portion
  private isAddressHintRight(source: Token[]) {
    for (let i = 0; i < source.length; i++) {
      const curTok = source[i];
      if (curTok.tokenType === TokenType.COLON) {
        if (source[i - 1].lexeme === "8" && source[i + 1].lexeme === "19") {
          return false;
        } else if (
          source[i - 1].lexeme === "28" &&
          source[i + 1].lexeme === "39"
        ) {
          return true;
        }
      }
    }
  }

  private isJumpAddressRight(source: Token[]) {
    for (let i = 0; i < source.length; i++) {
      const curTok = source[i];
      if (curTok.tokenType === TokenType.COLON) {
        if (source[i - 1].lexeme === "0" && source[i + 1].lexeme === "19") {
          return false;
        } else if (
          source[i - 1].lexeme === "20" &&
          source[i + 1].lexeme === "39"
        ) {
          return true;
        }
      }
    }
  }

  // Only used to get immediate value in STORI instruction
  private getImmediateValue(source: Token[]) {
    for (let i = 0; i < source.length; i++) {
      const curTok = source[i];
      if (
        curTok.tokenType == TokenType.MEMORY_ADDRESS_DEC &&
        source[i - 1].tokenType == TokenType.COMMA
      ) {
        const value = parseInt(curTok.lexeme);
        if (Number.isNaN(value)) {
          throw new Error(
            `Could not convert to a valid immediate number. Number: ${curTok.lexeme}`
          );
        }
        return value;
      }
    }

    return null;
  }
}
