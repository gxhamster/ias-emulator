// Parser takes a list of tokens generated by the 

import { Instruction } from "../emulator/emulator";
import { Opcode } from "../emulator/opcodes";
import { TokenType, type Token } from "./lexer";
import { ADD, DIV, JUMP_COND_LEFT, JUMP_COND_RIGHT, JUMP_LEFT, JUMP_RIGHT, LOAD_FROM_MEMORY, LOAD_FROM_MEMORY_ABS, LOAD_FROM_MEMORY_ABS_NEG_OFF, LOAD_FROM_MEMORY_NEG_OFF, LOAD_FROM_MQ, LOAD_TO_MQ, LSH, MUL, RSH, STOR_REPLACE_LEFT, STOR_REPLACE_RIGHT, STOR_TO_MEMORY, SUB } from "./tokenMappings";

// Scanner class and maps them to actual instructions
export class Parser {
    private totalTokens: Array<Array<Token>> = new Array()
    public instructions: Array<Instruction> = new Array();

    constructor(tokens: Token[]) {
        if (!tokens.length)
            throw new Error(`Cannot parse if tokens are empty! -> ${tokens}`)

        // Address translation
        tokens = this.parseHexAddressToBase10(tokens);

        // Instructions in each line grouped together
        for (const token of tokens) {
            if (!this.totalTokens[token.line]) {
                this.totalTokens[token.line] = []
            }
            this.totalTokens[token.line].push(token);
        }

    }

    // As a preliminary step convert all hex to dec. This is for 
    // consistency and so that we dont have to match for two versions
    // in the parsing process.
    private parseHexAddressToBase10(tokens: Token[]) {
        for (let i = 0; i < tokens.length; i++) {
            if (tokens[i].tokenType == TokenType.MEMORY_ADDRESS_HEX) {
                const base10 = parseInt(tokens[i].lexeme, 16);
                if (!Number.isNaN(base10)) {
                    tokens[i].lexeme = base10.toString()
                } else {
                    throw new Error(`Error occured during address translation to base10, Token: ${tokens[i]}`)
                }
            }
        }

        return tokens;
    }

    parse() {
        // Pattern match for each instruction using the token type
        let curTokens: Token[] = Array();
        for (let i = 0; i < this.totalTokens.length; i++) {
            curTokens = this.totalTokens[i];

            // Generate instructions
            if (this.matchTokens(curTokens, LOAD_FROM_MEMORY)) {
                const addr = this.getAddressFromInstructionTokens(curTokens)
                this.addInstruction(new Instruction(Opcode.LOAD, addr))
            } else if (this.matchTokens(curTokens, LOAD_FROM_MEMORY_NEG_OFF)) {
                const addr = this.getAddressFromInstructionTokens(curTokens)
                this.addInstruction(new Instruction(Opcode.LOAD_NEG, addr))
            } else if (this.matchTokens(curTokens, LOAD_FROM_MEMORY_ABS)) {
                const addr = this.getAddressFromInstructionTokens(curTokens)
                this.addInstruction(new Instruction(Opcode.LOAD_ABS, addr))
            } else if (this.matchTokens(curTokens, LOAD_FROM_MEMORY_ABS_NEG_OFF)) {
                const addr = this.getAddressFromInstructionTokens(curTokens)
                // this.addInstruction(new Instruction(Opcode.LOAD, addr))
                throw new Error("Not implemented instruction!")
            } else if (this.matchTokens(curTokens, ADD)) {
                const addr = this.getAddressFromInstructionTokens(curTokens)
                this.addInstruction(new Instruction(Opcode.ADD, addr))
            } else if (this.matchTokens(curTokens, SUB)) {
                const addr = this.getAddressFromInstructionTokens(curTokens)
                this.addInstruction(new Instruction(Opcode.SUB, addr))
            } else if (this.matchTokens(curTokens, LOAD_TO_MQ)) {
                const addr = this.getAddressFromInstructionTokens(curTokens)
                this.addInstruction(new Instruction(Opcode.LOAD_TO_MQ, addr))
            } else if (this.matchTokens(curTokens, LOAD_FROM_MQ)) {
                this.addInstruction(new Instruction(Opcode.LOAD_FROM_MQ))
            } else if (this.matchTokens(curTokens, MUL)) {
                const addr = this.getAddressFromInstructionTokens(curTokens)
                this.addInstruction(new Instruction(Opcode.MUL, addr));
            } else if (this.matchTokens(curTokens, DIV)) {
                const addr = this.getAddressFromInstructionTokens(curTokens)
                this.addInstruction(new Instruction(Opcode.DIV, addr));
            } else if (this.matchTokens(curTokens, JUMP_LEFT)) {
                const addr = this.getAddressFromInstructionTokens(curTokens)
                this.addInstruction(new Instruction(Opcode.JUMP_LEFT, 0x0, 0x0, addr));
            } else if (this.matchTokens(curTokens, JUMP_RIGHT)) {
                const addr = this.getAddressFromInstructionTokens(curTokens)
                this.addInstruction(new Instruction(Opcode.JUMP_RIGHT, addr));
            } else if (this.matchTokens(curTokens, JUMP_COND_LEFT)) {
                const addr = this.getAddressFromInstructionTokens(curTokens)
                this.addInstruction(new Instruction(Opcode.COND_JUMP_LEFT, 0x0, 0x0, addr));
            } else if (this.matchTokens(curTokens, JUMP_COND_RIGHT)) {
                const addr = this.getAddressFromInstructionTokens(curTokens)
                this.addInstruction(new Instruction(Opcode.JUMP_RIGHT, addr));
            } else if (this.matchTokens(curTokens, STOR_REPLACE_LEFT)) {
                this.addInstruction(new Instruction(Opcode.LEFT_ADDR_MODIFY));
            } else if (this.matchTokens(curTokens, STOR_REPLACE_RIGHT)) {
                this.addInstruction(new Instruction(Opcode.RIGHT_ADDR_MODIFY));
            } else if (this.matchTokens(curTokens, LSH)) {
                this.addInstruction(new Instruction(Opcode.LSH));
            } else if (this.matchTokens(curTokens, RSH)) {
                this.addInstruction(new Instruction(Opcode.RSH));
            } else if (this.matchTokens(curTokens, STOR_TO_MEMORY)) {
                const addr = this.getAddressFromInstructionTokens(curTokens)
                this.addInstruction(new Instruction(Opcode.STOR, addr))
            } else {
                throw new Error(`Unknown instruction pattern used, Instructions pattern: ${this.displayInstructionTokens(curTokens)}`)
            }

        }
    }

    // Tries to get the address parameter required by the 
    // instruction. Returns the first address token it finds
    // TODO: Could be bad
    private getAddressFromInstructionTokens(tokens: Token[]) {
        let address: number;
        for (const token of tokens) {
            if (token.tokenType === TokenType.MEMORY_ADDRESS_DEC) {
                // All addreses should be converted to base 10 by now
                address = parseInt(token.lexeme)
                if (Number.isNaN(address)) {
                    throw new Error("Could not get address from tokens list!")
                }
                return address;
            }

        }
    }

    private displayInstructionTokens(tokens: Token[]) {
        // Join everything after the opcode
        const temp = tokens.filter((tok, idx) => idx > 0);
        const lexemes = temp.map(tok => tok.lexeme);
        return `${tokens[0].lexeme} ${lexemes.join("")}`
    }

    private addInstruction(instruction: Instruction) {
        this.instructions.push(instruction);
    }

    // Check if any two arrays of tokens are the same
    private matchTokens(line: Token[], reference: TokenType[]) {
        if (line.length != reference.length)
            return false
        for (let i = 0; i < reference.length; i++) {
            if (line[i].tokenType != reference[i])
                return false
        }

        return true
    }
}